# Obtain the maximum value of the shortest curve (refers to take the last number before the NA values start that is the lowest)
minimum = 1000000000
for i in range(energy_m.shape[0]):
  if minimum > energy_m.iloc[i, energy_m.notna().sum(axis=1)[i] - 1]:
    minimum = energy_m.iloc[i, energy_m.notna().sum(axis=1)[i] - 1]
    minimum_index = i
    
print(f'Minimum: {minimum}')
print(f'Minimum index: {minimum_index}')

# Loading the dataframes
energy_m_reduced = pd.read_csv(r'C:\Users\Elías Jr\Desktop\TFG\Dataframes\Nuevos Datos\energy_m.csv')
prices_m_reduced = pd.read_csv(r'C:\Users\Elías Jr\Desktop\TFG\Dataframes\Nuevos Datos\prices_m.csv')

# Define a new dataframe in the range [0, Q*], where Q* is the maximum value of energy of the shortest curve
for r in range(energy_m_reduced.shape[0]):
  valor_superado = False
  for c in range(2, energy_m_reduced.shape[1]):
    if valor_superado:
        # If the value has already been exceeded, put the value as NaN
        energy_m_reduced.iloc[r, c] = np.nan
        prices_m_reduced.iloc[r,c] = np.nan
    elif energy_m_reduced.iloc[r,c] >= minimum:
        # If the value is equal or higher than 'minimum', set the flag to True
        valor_superado = True
        energy_m_reduced.iloc[r,c] = minimum
